# 填充和步幅
本节我们将介绍填充（padding）和步幅（stride）。假设以下情景： 
有时，在应用了连续的卷积之后，我们最终得到的输出远小于输入大小。
这是由于卷积核的宽度和高度通常大于
所导致的。比如，一个240x240 像素的图像，经过10层 5x5的卷积后，将减少到200x200
像素。如此一来，原始图像的边界丢失了许多有用信息。
而填充是解决此问题最有效的方法； 
有时，我们可能希望大幅降低图像的宽度和高度。例如，
如果我们发现原始的输入分辨率十分冗余。步幅则可以在这类情况下提供帮助。

## 填充
如上所述，在应用多层卷积时，我们常常丢失边缘像素。 由于我们通常使用小卷积核，
因此对于任何单个卷积，我们可能只会丢失几个像素。 但随着我们应用许多连续卷积层，
累积丢失的像素数就多了。 解决这个问题的简单方法即为填充（padding）：
在输入图像的边界填充元素（通常填充元素是 0）。 
例如，在下图中，我们将3x3输入填充到5x5，那么它的输出就增加为4x4 。
阴影部分是第一个输出元素以及用于输出计算的输入和核张量元素：0x0+0x1+0x2+0x3=0
。

![示例图片](pics/img_3.png)

假设我们原张量形状为nxn，卷积核为kxk，我们在原张量的基础上填充A行，在原张量基础上
填充B列，那么在进行互相关运算后，得到的输出形状为(n+A-k+1)x(n+B-K+1),
在图中的例子中，输出初始是3x3，我们在填充了两行（上下各一行）以及两列，那么新的张量
为5x5， 通过运算后，得到形状为(5-2+1)x(5-2+1)

在下面的例子中，我们创建一个高度和宽度为3的二维卷积层，并在所有侧边填充1个像素。
给定高度和宽度为8的输入，则输出的高度和宽度也是8。
```bash
import torch
from torch import nn


# 为了方便起见，我们定义了一个计算卷积层的函数。
# 此函数初始化卷积层权重，并对输入和输出提高和缩减相应的维数
def comp_conv2d(conv2d, X):
    # 这里的（1，1）表示批量大小和通道数都是1
    X = X.reshape((1, 1) + X.shape)
    Y = conv2d(X)
    # 省略前两个维度：批量大小和通道
    return Y.reshape(Y.shape[2:])

# 请注意，这里每边都填充了1行或1列，因此总共添加了2行或2列
conv2d = nn.Conv2d(1, 1, kernel_size=3, padding=1)
X = torch.rand(size=(8, 8))
comp_conv2d(conv2d, X).shape
```
输出是：
```bash
torch.Size([8, 8])
```
## 步幅
在计算互相关时，卷积窗口从输入张量的左上角开始，向下、向右滑动。 在前面的例子中
，我们默认每次滑动一个元素。 但是，有时候为了高效计算或是缩减采样次数，
卷积窗口可以跳过中间位置，每次滑动多个元素。

我们将每次滑动元素的数量称为步幅（stride）。到目前为止，我们只使用过高度或
宽度为1 的步幅，那么如何使用较大的步幅呢？ 下图是垂直步幅为3 ，水平步幅为2
的二维互相关运算。 着色部分是输出元素以及用于输出计算的输入和内核张量元素：

![示例图片](pics/img_4.png)

在这里给出输出形状的新计算公式：

![示例图片](pics/img_5.png)

其中除法运算均向下取整。以图中举例，初始为3x3，填充2行2列，在水平方向步长为2
，在竖直方向步长为3，那么有在水平方向有(3-2+2+2)/2=2(注意向下取整)，在竖直
方向(3-2+2+3)/3=2,最后输出为2x2

```bash
conv2d = nn.Conv2d(1, 1, kernel_size=3, padding=1, stride=2)
comp_conv2d(conv2d, X).shape
```
输出：
```bash
torch.Size([4, 4])
```
```bash
conv2d = nn.Conv2d(1, 1, kernel_size=(3, 5), padding=(0, 1), stride=(3, 4))
comp_conv2d(conv2d, X).shape
```
输出：
```bash
torch.Size([2, 2])
```